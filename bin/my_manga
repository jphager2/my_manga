#!/Users/jph/.rvm/rubies/ruby-2.1.5/bin/ruby

require_relative '../db/environment'
require_relative '../lib/my_manga'

FETCHED_MANGA_CHAPTERS = {
  "Assassination Classroom" => (1..166).to_a,
  "Naruto" => (1..700).to_a,
  "Naruto Movie" => (1..10).to_a
}

FETCHED_MANGA_DATA = {
  "assassination classroom" => [
    { name: "Assassination Classroom", uri: "http://www.mangareader.net/assassination-classroom" }
  ]
}
 
def find(search)
  data = FETCHED_MANGA_DATA[search]

  puts "Manga found for \"#{search}\""
  puts "=" * (18 + search.length)

  if data
    column_width = data.map { |r| r[:name].length }.max
    puts "Name".ljust(column_width + 2, ' ') + "Url"
    data.each do |result|
      puts result[:name].ljust(column_width + 2, " ") + result[:uri]
    end
  end
end

def add(uri)
  if manga = MyManga.add(uri)
    puts "\"#{manga.name}\" added to your library!"
  end
end

def remove(name)
  if MyManga.remove(name)
    puts "\"#{name}\" removed from your library!"
  end
end

def list_detail(name)
  manga = MyManga[name]
  header = "Manga details for \"#{manga.name}\"" 
  chapters = manga.chapters_read

  puts header
  puts "=" * header.length
  puts "Name".ljust(name.length + 2, " ") + "Chapters (read/total)"
  puts "#{name}  #{manga.read_count}/#{manga.total_count}"
  puts
  puts "Chapters Read"
  puts "-------------"
  if chapters.length > 4
    chapters[0..2].each do |chapter|
      puts chapter.name
    end
    puts "..."
    puts chapters[-1].name
  else
    chapters[0..2].each do |chapter|
      puts chapter.name
    end
  end
end

def list(names)
  if names.length == 1 
    list_detail(names[0])
  else
    column_width = names.map(&:length).max || 10

    puts "Manga list"
    puts "=========="
    puts "Name".ljust(column_width + 2, " ") + "Chapters (read/total)"
    
    names.each do |name|
      manga = MyManga[name]
      puts name.ljust(column_width + 2, " ") + "#{manga.read_count}/#{manga.total_count}"
    end
  end
end

def download_with_options(names, options)
  names.each do |name| 
    manga = MyManga[name]
    if options.empty? || options[:all]
      numbers = manga.chapters_unread_numbers
    else
      numbers = options.fetch(:list) { 
        (options.fetch(:from)..options.fetch(:to)).to_a
      }
    end
    count = numbers.length

    if count > 0
      puts "Downloading #{count} Chapters from \"#{name}\""
      MyManga.download(manga, numbers)
    end
  end
  puts "Finished Download!"
end

def update(manga)
  MyManga.update(manga)
  #manga.update_chapters(FETCHED_MANGA_CHAPTERS[manga.name])
end

def update_with_options(names, options)
  if options.empty?
    puts "Fetching Manga"
    puts "..."
    names.each do |name|
      manga = MyManga[name]
      old_total = manga.total_count
      update(manga)
      new_total = MyManga[name].total_count
      updated = new_total - old_total
      if updated > 0
        puts "Updated \"#{name}\": #{updated} new Chapters."
      end
    end
  else
    # Do somethign with options
  end
end

def mark(manga, flag, chapters)
  if flag == "read"
    MyManga.read!(manga, chapters)
  else
    MyManga.unread!(manga, chapters)
  end
end

def mark_with_options(names, flag, options)
  if options.has_key?(:list)
    chapters = options.fetch(:list).map(&:to_i)
    output =  chapters.join(', ')
  else
    from = options.fetch(:from).to_i
    to = options.fetch(:to).to_i
    chapters = (from..to).to_a
    output = "#{from}-#{to}"
  end

  names.each do |name|
    manga = MyManga[name]
    mark(manga, flag, chapters)
    puts "Chapters #{output} from \"#{name}\" Marked as #{flag.capitalize}"
  end
end

def my_manga(names)
  MyManga.names & names
end

require 'optparse'
def options_from_args(action)
  options = {}
  opts = OptionParser.new do |opts|
    opts.on("-a", "--all", "Explicity run for all manga") do
      options[:all] = true
    end

    opts.on("--from FROM", Integer, "Chapter from") do |from|
      options[:from] = from
    end

    opts.on("--to TO", Integer, "Chapter to") do |to|
      options[:to] = to
    end

    opts.on("--list x,y,x", Array, "List of Chapters") do |list|
      options[:list] = list
    end
  end
  opts.parse!

  if [options[:from], options[:to]].compact.length == 1
    raise OptionParser::MissingArgument, "`--from` must always be given with `--to`"
  end

  if action == :mark
    if [options[:list], options[:from]].compact.length == 0
      raise OptionParser::MissingArgument, "`--list` or `--from` and `--to` required for `mark`"
    end
  end

  options
end

def sanitized_input(input)
  if input[0] == input[-1] 
    input = input.sub(/^["']/, "")
    input.sub(/["']$/, "")
  else
    input
  end
end

def manga_name_arg_or_all
  if !ARGV[0] || ARGV[0].start_with?("-")
    MyManga.names
  else
    manga = sanitized_input(ARGV.shift)
    manga = Array(manga)
    my_manga(manga)
  end
end

action = ARGV.shift
case action
when "find"
  if ARGV[0]
    manga = sanitized_input(ARGV[0])
    find(manga) 
  end
when "add"
  if ARGV[0]
    uri = sanitized_input(ARGV[0])
    add(uri) 
  end
when "remove"
  if ARGV[0]
    manga = sanitized_input(ARGV[0])
    remove(manga) 
  end
when "list"
  manga = manga_name_arg_or_all
  list(manga)
when "download"
  manga = manga_name_arg_or_all
  download_with_options(manga, options_from_args(:download))
when "update"
  manga = manga_name_arg_or_all
  update_with_options(manga, options_from_args(:update))
when "mark"
  if %w{ read unread }.include?(ARGV[0])
    mark = ARGV.shift
    manga = manga_name_arg_or_all
    mark_with_options(manga, mark, options_from_args(:mark))
  else
    raise ArgumentError, "`mark` requires either `read` or `unread`"
  end
when "env"
  puts MyManga.env
else
  puts ARGV.inspect
end
