#!/usr/bin/ruby
MANGA = {
  "Assassination Classroom" => [0, 161],
  "Naruto" => [669, 700],
  "Naruto Movie" => [10, 10]
}

FETCHED_MANGA_CHAPTERS = {
  "Assassination Classroom" => (1..166).to_a,
  "Naruto" => (1..700).to_a,
  "Naruto Movie" => (1..10).to_a
}
 
def find(manga)
  manga = manga[1..-2] if manga[0] == manga[-1] && manga[0] == '"' || manga[0] == "'"
  name = manga.split(/\s/).each(&:capitalize!).join(" ")
  url = "http://www.mangareader.net/assassination-classroom"
  found_line = "Manga found for \"#{manga}\""
  break_line = "=" * found_line.length
  header_line = "Name".ljust(name.length + 2, ' ') + "Url"
  results_line = "#{name}  #{url}"

  puts found_line
  puts break_line
  puts header_line
  puts results_line
end

def list_detail(manga)
end

def list(manga)
  if manga.length == 1
    list_detail(manga[0])
  else
    column_width = manga.map(&:length).max

    puts "Manga list"
    puts "=========="
    puts "Name".ljust(column_width + 2, " ") + "Chapters (read/total)"
    
    MANGA.each do |name, (read, total)|
      puts name.ljust(column_width + 2, " ") + "#{read}/#{total}"
    end
  end
end

def download(manga, chapters)
end

def unread_chapter_groups(manga)
  Hash.new { |h,k| h[k] = [] }.merge(
    "Assassination Classroom" => [(0..161)],
    "Naruto" => [(669..700)],
    "Naruto Movie" => []
  )[manga]
end

def download_with_options(manga, options)
  if options.empty?
    manga.each do |name| 
      total = MANGA[name][1]
      groups = unread_chapter_groups(name) 
      count = groups.inject(0) { |total, g| total + g.size }
      puts "Downloading #{count} Chapters from \"#{name}\""
      groups.each do |group|
        download(name, group) 
      end
    end
  else
    # Do something with options
  end
  puts "Finished Download!"
end

def update(manga)
  MANGA[manga][1] = FETCHED_MANGA_CHAPTERS[manga].length
end

def update_with_options(manga, options)
  if options.empty?
    puts "Fetching Manga"
    puts "..."
    manga.each do |name|
      old_total = MANGA[name][1]
      update(name)
      new_total = MANGA[name][1]
      updated = new_total - old_total
      if updated > 0
        puts "Updated \"#{name}\": #{updated} new Chapters."
      end
    end
  else
    # Do somethign with options
  end
end

def mark(manga, flag, chapters)
end

def mark_with_options(manga, flag, options)
  if options.has_key?(:list)
    chapters = options.fetch(:list).map(&:to_i)

    manga.each do |name|
      mark(name, flag, chapters)

      puts "Chapters #{chapters.join(', ')} from \"#{name}\" Marked as Unread"
    end
  else
    from = options.fetch(:from).to_i
    to = options.fetch(:to).to_i

    manga.each do |name|
      mark(name, flag, from..to)

      puts "Chapters #{from}-#{to} from \"#{name}\" Marked as #{flag.capitalize}"
    end
  end
end

def my_manga(names)
  MANGA.keys & names
end

require 'optparse'
def options_from_args(action)
  options = {}
  opts = OptionParser.new do |opts|
    opts.on("-a", "--all", "Explicity run for all manga") do
      options[:all] = true
    end

    opts.on("--from FROM", Integer, "Chapter from") do |from|
      options[:from] = from
    end

    opts.on("--to TO", Integer, "Chapter to") do |to|
      options[:to] = to
    end

    opts.on("--list x,y,x", Array, "List of Chapters") do |list|
      options[:list] = list
    end
  end
  opts.parse!

  if [options[:from], options[:to]].compact.length == 1
    raise OptionParser::MissingArgument, "`--from` must always be given with `--to`"
  end

  if action == :mark
    if [options[:list], options[:from]].compact.length == 0
      raise OptionParser::MissingArgument, "`--list` or `--from` and `--to` required for `mark`"
    end
  end

  options
end

def manga_name_arg_or_all
  if !ARGV[0] || ARGV[0].start_with?("-")
    MANGA.keys
  else
    manga = ARGV.shift.gsub(/["']/, "")
    manga = Array(manga)
    my_manga(manga)
  end
end

action = ARGV.shift
case action
when "find"
  find(ARGV[0]) if ARGV[0]
when "list"
  manga = manga_name_arg_or_all
  list(manga)
when "download"
  manga = manga_name_arg_or_all
  download_with_options(manga, options_from_args(:download))
when "update"
  manga = manga_name_arg_or_all
  update_with_options(manga, options_from_args(:update))
when "mark"
  if %w{ read unread }.include?(ARGV[0])
    mark = ARGV.shift
    manga = manga_name_arg_or_all
    mark_with_options(manga, mark, options_from_args(:mark))
  end
else
  puts ARGV.inspect
end
